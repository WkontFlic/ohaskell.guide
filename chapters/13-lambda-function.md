# Лямбда-функция

Пришло время познакомиться с важной концепцией &mdash; лямбда-функцией. Именно с неё всё и началось. Приготовьтесь: в этой главе нас ждут новые открытия.

## Истоки

В 1930-х молодой американский математик [Алонзо Чёрч](https://en.wikipedia.org/wiki/Alonzo_Church) задался вопросом о том, что значит &laquo;вычислить&raquo; что-либо. Плодом его размышлений явилась система для формализации понятия &laquo;вычисление&raquo;, и назвал он эту систему &laquo;лямбда-исчислением&raquo; (по имени греческой буквы `λ`). В основе этой системы лежит лямбда-функция, которую можно считать &laquo;матерью функционального программирования&raquo; в целом и Haskell в частности. Далее буду называть её ЛФ.

В отношении ЛФ можно смело сказать: &laquo;Всё гениальное просто&raquo;. Идея ЛФ столь полезна именно потому, что она предельно проста. Вот как она выглядит в Haskell:

```haskell
\x -> x * x
```

Обратный слэш в начале &mdash; признак ЛФ. Сравните с математической формой записи:

```haskell
λx . x * x
```

Похоже, не правда ли? Воспринимайте обратный слэш в определении ЛФ как спинку буквы `λ`.

ЛФ представляет собой простейший вид функции, эдакая функция, раздетая догола. У неё забрали не только объявление, но и имя, оставив лишь необходимый минимум в виде имён аргументов и внутреннего выражения. поэтому иногда её называют &mdash; - анонимная функция. Чтобы применить функцию, вовсе необязательно её именовать. И если у обычной функции сначала идёт объявление/определение, а затем (где-то) применение с использованием имени, то у ЛФ всё куда проще: мы её определяем и тут же применяем, на месте. Вот так:

```haskell
(\x -> x * x) 5
```

Помните функцию `квадрат` - вычисления квадрата числа? Вот это её лямбда-аналог:

```haskell
(\x -> x * x)      5

лямбда-абстракция  аргумент
```

Лямбда-абстракция (англ. lambda abstraction) &mdash; это особое выражение, порождающее функцию, которую мы сразу же применяем к аргументу `5`. ЛФ с одним аргументом, как и простую функцию, называют ещё &laquo;ЛФ от одного аргумента&raquo; или &laquo;ЛФ одного аргумента&raquo;. Также можно сказать и о &laquo;лямбда-абстракции от одного аргумента&raquo;.

## Строение

Строение лямбда-функций предельно простое:

```haskell
\        x          ->  x * x
признак  имя            выражение
ЛФ       аргумента
```

Соответственно, если ЛФ применяется к 2-м аргументам &mdash; пишем так:

```haskell
\        x          y          ->  x * y
признак  имя 1      имя 2          выражение
ЛФ       аргумента  аргумента
```

И когда мы применяем такую функцию:

```haskell
(\x y -> x * y) 10 4
```

то просто подставляем `10` на место `x`, а `4` &mdash; на место `y`, и получаем выражение `10 * 4`:

```haskell
  (\x y -> x * y) 10 4
= 10 * 4
= 40
```

В общем, всё как с обычной функцией, даже проще.

Мы можем ввести промежуточное значение для лямбда-функции:

```haskell
main :: IO ()
main = print (умножить 10 4)
  where умножить = \x y -> x * y  -- здесь мы фактически дали имя `умножить` лямбда-функции `x * y`
  -- Если ещё сильнее упростить лямбда-функция - это имя для куска математической формулы
```

Теперь мы можем применять `умножить` так же, как если бы это была сама лямбда-функция:

```haskell
  умножить 10 4
= (\x y -> x * y) 10 4
= 10 * 4
```

И здесь мы приблизились к одному важному открытию.

## Тип функции

Мы знаем, что у всех данных в Haskell-программе обязательно есть какой-то тип, внимательно проверяемый на этапе компиляции. Вопрос: какой тип у выражения `умножить` из предыдущего примера?

```haskell
  where умножить = \x y -> x * y  -- Какой тип?
```

Ответ прост: тип `умножить` такой же, как и у этой лямбда-абстракции. Из этого мы делаем важный вывод: ЛФ имеет тип, как и обычные данные. Но поскольку ЛФ является частным случаем обычной функции &mdash; значит и у обыкновенной функции тоже есть тип!

В нефункциональных языках между функциями и данными проведена чёткая граница: вот это функции, а вон то &mdash; данные. Однако в Haskell между данными и функциями разницы нет, ведь и то и другое покоится на одной и той же Черепахе. Вот тип функции `умножить`:

```haskell
умножить :: a -> a -> a
```

Погодите, скажете вы, но ведь это же объявление функции! Совершенно верно: объявление функции &mdash; это и есть указание её типа. Помните, когда мы впервые познакомились с функцией, я уточнил, что её объявление разделено двойным двоеточием? Так вот это двойное двоеточие и представляет собой указание типа:

```haskell
умножить  ::  a -> a -> a

вот  имеет   │   вот   │
это          └─ такой ─┘
                 тип
```

Что это за буква `a`? Во-первых, мы не встречали такой тип ранее, а во-вторых, разве имя типа в Haskell не обязано начинаться с большой буквы? Обязано. А всё дело в том, что буква `a` в данном случае &mdash; это не совсем имя типа. А вот что это такое, мы узнаем в одной из ближайших глав.

Точно так же мы можем указать тип любых других данных:

```haskell
let коэфициент = 12 :: Double
```

Хотя мы знаем, что в Haskell типы выводятся автоматически, иногда мы хотим взять эту заботу на себя. В данном случае мы явно говорим: &laquo;Пусть выражение `коэфициент` будет равно `12`, но тип его пусть будет `Double`, а не `Int`&raquo;. Так же и с функцией: когда мы объявляем её &mdash; мы тем самым указываем её тип.

Но вы спросите, можем ли мы не указывать тип функции явно? Можем:

```haskell
квадрат число = число * число
```

Это наша старая знакомая, функция `квадрат`. Когда она будет применена к значению типа `Int`, тип аргумента будет выведен автоматически как `Int`.

И раз функция характеризуется типом так же, как и прочие данные, мы делаем ещё одно важное открытие: функциями можно оперировать как данными. Например, можно создать список функций:

```haskell
main :: IO ()
main = putStrLn ((head functions) "Привет")
  where
    functions = [ \x -> x ++ " val1"
                , \x -> x ++ " val2"
                ]  -- список из 2-х функций. Эти функции образуются из двух лямбда-выражений.
```

Выражение `functions` &mdash; это список из 2-х функций. Два лямбда-выражения порождают эти две функции, но до момента применения они ничего не делают, они безжизненны и бесполезны. Но когда мы применяем функцию `head` к списку `functions`, мы получаем 1-й элемент списка, то есть 1- ю функцию. И получив, тут же применяем эту функцию к строке `"Привет"`:

```haskell
putStrLn ((head functions)  "Привет")

         |получает первую│  аргумент
         │   функцию     │  этой 
         └─ из списка  ──┘  функции
```

Это равносильно коду:

```haskell
putStrLn ((\x -> x ++ " val1") "Привет")
```

При запуске программы мы получим:

```bash
Привет val1
```

Кстати, а какой тип списка `functions`? Его тип таков: `[String -> String]`. То есть список функций с одним аргументом типа `String`, возвращающих значение типа `String`.

## Локальные функции

Раз уж между ЛФ и простыми функциями фактически нет различий, а функции есть частный случай данных, мы можем создавать функции локально для других функций:

```haskell
-- Здесь определены функции
-- isInfixOf и isSuffixOf.
import Data.List
-- функция проверкаАдресаЭлПочты
проверкаАдресаЭлПочты :: String -> Bool -- принимает строку, возвращате Да (True) или Нет (Falce)
проверкаАдресаЭлПочты элПочта =
    содержитАТсимвол элПочта && оканчиваетсяНаCom элПочта -- строка - адрес электроПочты если содержит символ АТ (@) и (&&) оканчивается на ".com"
  where
    содержитАТсимвол проверяемаяСтрока = "@" `isInfixOf` проверяемаяСтрока
    -- функция isInfixOf, используется как оператор - проверяет строку "проверяемаяСтрока" на содержание сивола АТ - @
    оканчиваетсяНаCom проверяемаяСтрока = ".com" `isSuffixOf` проверяемаяСтрока
    -- функция isSuffixOf, используется как оператор - проверяет что строка "проверяемаяСтрока" оканчивается на ".com"

main :: IO ()
-- проверяет строку `мояПочта` на соответстиве признакам адреса эл.почты 
main = putStrLn (if проверкаАдресаЭлПочты мояПочта
                   then "Адрес эл. почты - правильный!"
                   else "Это на адрес эл. почты окначиающийся на .com!")
  where
    мояПочта = "haskeller@gmail.com" -- строка которая проверяется на соответствие признакам адреса эл.почты
```

Несколько упрощенная функция `проверкаАдресаЭлПочты` проверяет `.com`-адрес. Её выражение образовано оператором `&&` - логическое "И" и двумя выражениями типа `Bool`. Вот как образованы эти выражения:

```haskell
содержитАТсимвол проверяемаяСтрока = "@" `isInfixOf` проверяемаяСтрока
-- функция isInfixOf, используется как оператор - проверяет строку "проверяемаяСтрока" на содержание сивола АТ - @
оканчиваетсяНаCom проверяемаяСтрока = ".com" `isSuffixOf` проверяемаяСтрока
-- функция isSuffixOf, используется как оператор - проверяет что строка "проверяемаяСтрока" оканчивается на ".com"
```

Это &mdash; две функции, которые мы определили прямо в `where`-секции, поэтому они существуют только для основного выражения функции `проверкаАдресаЭлПочты`. С простыми функциями так поступают очень часто: где она нужна, там её и определяют. 

Мы могли бы написать и более явно:

```haskell
проверкаАдресаЭлПочты :: String -> Bool
проверкаАдресаЭлПочты элПочта =
    содержитАТсимвол элПочта && оканчиваетсяНаCom элПочта
  where
    -- Объявляем локальную функцию `содержитАТсимвол` явно
    содержитАТсимвол :: String -> Bool
    содержитАТсимвол проверяемаяСтрока = "@" `isInfixOf` проверяемаяСтрока

    -- Объявляем локальную функцию `оканчиваетсяНаCom` явно
    оканчиваетсяНаCom :: String -> Bool
    оканчиваетсяНаCom проверяемаяСтрока = ".com" `isSuffixOf` проверяемаяСтрока
```

Впрочем, указывать тип (String -> Bool) столь простых функций, как правило, необязательно.

Вот как этот код выглядит с лямбда-абстракциями:

```haskell
проверкаАдресаЭлПочты :: String -> Bool
проверкаАдресаЭлПочты элПочта =
    содержитАТсимвол элПочта && оканчиваетсяНаCom элПочта
    -- к строке "элПочта" применяются две лямбда-функции "содержитАТсимвол" и "оканчиваетсяНаCom"
  where
    содержитАТсимвол = \проверяемаяСтрока -> "@" `isInfixOf` проверяемаяСтрока
    -- определяется лямбда-функция с именем "содержитАТсимвол" и параметром "проверяемаяСтрока"
    оканчиваетсяНаCom = \проверяемаяСтрока -> ".com" `isSuffixOf` проверяемаяСтрока
    -- определяется лямбда-функция с именем "оканчиваетсяНаCom" и параметром "проверяемаяСтрока"
```

Теперь выражения `содержитАТсимвол` и `оканчиваетсяНаCom` приравнены к ЛФ от одного аргумента. В этом случае мы не указываем тип этих выражений.

Впрочем, если очень хочется, можно и указать:

```haskell
содержитАТсимвол =
    (\проверяемаяСтрока -> "@" `isInfixOf` проверяемаяСтрока) :: String -> Bool

                           лямбда-абстракция                     тип этой абстракции
```

ВАЖНО! Лямбда-абстракция взята в скобки, чтобы указание типа относилось к функции в целом, а не только к аргументу `проверяемаяСтрока`:

```haskell
содержитАТсимвол =
    \проверяемаяСтрока -> "@" `isInfixOf` проверяемаяСтрока :: String -> Bool

                                                               в этом случае это тип аргумента "проверяемаяСтрока",
                                                               а вовсе не всей функции!
```
## Псевдоним для Типа Функции
Для типа функции тоже можно ввести псевдоним:

```haskell
-- Псевдоним для типа функции.
type ТипСтрокаЛог = String -> Bool

проверкаАдресаЭлПочты :: String -> Bool
проверкаАдресаЭлПочты элПочта =
    содержитАТсимвол элПочта && оканчиваетсяНаCom элПочта
  where
    содержитАТсимвол = (\проверяемаяСтрока -> "@" `isInfixOf` проверяемаяСтрока) :: ТипСтрокаЛог
    оканчиваетсяНаCom = (\проверяемаяСтрока -> ".com" `isSuffixOf` проверяемаяСтрока) :: ТипСтрокаЛог
```

Впрочем, на практике указание типа для лямбда-абстракций встречается исключительно редко, ибо незачем.

Отныне, познакомившись с ЛФ, мы будем использовать их периодически.
