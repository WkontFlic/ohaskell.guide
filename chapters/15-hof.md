# ФВП - Функции Высшего Порядка

ФВП, или Функции Высшего Порядка (англ. HOF, Higher Order Functions) &mdash; важная концепция в Haskell, с которой, однако, мы уже знакомы. Как мы узнали из предыдущих глав, функциями можно оперировать как значениями. Так вот функции, оперирующие другими функциями как аргументами и/или как результирующим выражением, носят название функций высшего порядка.

Так, оператор композиции функций является ФВП, потому что он:
- принимает функции в качестве аргументов
- возвращает другую функцию (в виде Лямбда-функции) как результат своего применения.

Использование функций в качестве аргументов &mdash; чрезвычайно распространённая практика в Haskell и других функциональных языках.

## Отображение

Рассмотрим функцию `map`. Эта стандартная функция используется для отображения (англ. mapping) функции на элементы списка. Пусть вас не смущает такой термин: отображение функции на элемент списка фактически означает применение функции к этому элементу списка. Если ещё проще - функция map принимает на вход другую функцию (например `квадрат`) и последовательно применяет её (передаёт функции `квадрат` на вход) последовательно к элементам списка, результаты выполнения функции `квадрат` функция map как правило заносит в другой список. Т.е. функция высшего порядка map оперирует другими функциями и данными которые они получают на вход и которые выдают. Функции которыми оперирует map называются функциями 1го порядка.

Вот объявление функции `map`:

```haskell
map :: (a -> b) -> [a] -> [b]
```

Вот опять эти маленькие буквы! Помните, я обещал рассказать о них? Рассказываю: маленькой буквой принято именовать полиморфный тип. Полиморфизм &mdash; это многообразность, многоформенность. В данном случае речь идёт не об указании конкретного типа, а о &laquo;типовой заглушке&raquo;. Мы говорим:

&laquo;Функция `map` применяется к функции из какого-то типа `a` в какой-то тип `b` и к списку типа `[a]`, а результат её работы &mdash; это другой список типа `[b]`&raquo;.

Типовой заглушкой я назвал их потому, что на их место встают конкретные типы, что делает функцию `map` очень гибкой.

Ещё раз:
- если функция map берёт какуюто функцию типа Char и которая возвращает тип Bool, то функция map берёт аргументы для подстановки в функцию из списка [Char] и помещет результат в список [Bool].
- если функция map берёт какуюто функцию типа String и которая возвращает тип Int, то функция map берёт аргументы для подстановки в функцию из списка [String] и помещет результат в список [Int].

Например:

```haskell
import Data.Char -- подключение стнадартного модуля
-- функция преобразования строки в верхний регистр
toUpperCase :: String -> String
toUpperCase строка = map toUpper строка

main :: IO ()
main = putStrLn . toUpperCase $ "haskell.org"
```

Результатом работы этой программы будет строка:

```bash
HASKELL.ORG
```

Функция `map` применяется к двум аргументам: к функции `toUpper` и к строке `str`. Функция `toUpper` из стандартного модуля `Data.Char` переводит символ типа `Char` в верхний регистр:

```haskell
toUpper 'a' = 'A'
```

Вот её объявление:

```haskell
toUpper :: Char -> Char
```

Функция из `Char` в `Char` выступает первым аргументом функции `map`, подставим сигнатуру:

```haskell
map :: (a    -> b)    -> [a] -> [b]
       (Char -> Char)
```

Ага, уже теплее! Мы сделали два новых открытия: во-первых, заглушки `a` и `b` могут быть заняты одним и тем же конкретным типом, а во-вторых, сигнатура позволяет нам тут же понять остальные типы. Подставим их:

```haskell
map :: (a    -> b)    -> [a]    -> [b]
       (Char -> Char)    [Char]    [Char]

        ____              ____

                ____                ____
```

А теперь вспомним о природе типа `String`:

```haskell
map :: (a    -> b)    -> [a]    -> [b]
       (Char -> Char)    String    String
```

Всё встало на свои места. Функция `map` в данном случае берёт функцию `toUpper` и бежит по списку, последовательно применяя функцию `toUpper` к элементам списка:

```haskell
map toUpper ['h','a','s','k','e','l','l','.','o','r','g']
```

Так, на первом шаге функция `toUpper` будет применена к элементу `'h'`, на втором &mdash; к элементу `'a'`, и так далее до последнего элемента `'g'`. Когда функция `map` бежит по этому списку, результат применения функции `toUpper` к его элементам служит элементами для второго списка, который и будет в конечном итоге возвращён. Так, результатом первого шага будет элемент `'H'`, результатом второго &mdash; элемент `'A'`, а результатом последнего &mdash; элемент `'G'`. Схема такова:

```haskell
map toUpper [ 'h'  >>  [ 'H'
            , 'a'  >>  , 'A'
            , 's'  >>  , 'S'
            , 'k'  >>  , 'K'
            , 'e'  >>  , 'E'
            , 'l'  >>  , 'L'
            , 'l'  >>  , 'L'
            , '.'  >>  , '.'
            , 'o'  >>  , 'O'
            , 'r'  >>  , 'R'
            , 'g'  >>  , 'G'
            ]          ]
```

Вот и получается:

```haskell
map toUpper "haskell.org" = "HASKELL.ORG"
```

Работа функции `map` выглядит как изменение списка, однако, в виду неизменности последнего, в действительности формируется новый список. Что самое интересное, функция `toUpper` пребывает в полном неведении о том, что ею в конечном итоге изменяют регистр целой строки, она знает лишь об отдельных символах этой строки. То есть функция, являющаяся аргументом функции `map`, ничего не знает о функции `map`, и это очень хорошо! Чем меньше функции знают друг о друге, тем проще и надёжнее использовать их друг с другом.

Рассмотрим другой пример, когда типовые заглушки `a` и `b` замещаются разными типами:

```haskell
toStr :: [Double] -> [String]  -- на вход спискок чисел Double на выходе список String
toStr числа = map show числа  -- функция `show` переводит свой единственный аргумент в строковый вид

main :: IO ()
main = print . toStr $ [1.2, 1, 4, 1.6]
```

Функция `toStr` работает уже со списками разных типов: на входе список чисел с плавающей точкой, на выходе список строк. При запуске этой программы мы увидим следующее:

```bash
["1.2","1.0","4.0","1.6"]
```

Уже знакомая нам стандартная функция `show` переводит свой единственный аргумент в строковый вид:

```haskell
show 1.2 = "1.2"
```

В данном случае, раз уж мы работаем с числами типа `Double`, тип функции `show` такой:

```haskell
show :: Double -> String
```

Подставим в сигнатуру функции `map`:

```haskell
map :: (a      -> b)      -> [a]      -> [b]
       (Double -> String)    [Double]    [String]

        ______                ______

                  ======                  ======
```

Именно так, как у нас и есть:

```haskell
map show [1.2, 1, 4, 1.6] = ["1.2","1.0","4.0","1.6"]
```
Кам это работает:
Функция map берёт из списка [1.2, 1, 4, 1.6] первое заначение 1.2 и передаёт его на вход функции show которая преобразет его в строку "1.2". Эту строку ("1.2") функция map помещает во вновь созданный список со строками - ["1.2","1.0","4.0","1.6"]. Затем берёт следующее значение из списка [1.2, 1, 4, 1.6] иопятьприменяет к нему функцию show. И так до конца списка  [1.2, 1, 4, 1.6].

Функция `map` применяет функцию `show` к числам из первого списка, на выходе получаем второй список, уже со строками. И как и в случае с `toUpper`, функция `show` ничего не подозревает о том, что ею оперировали в качестве аргумента функции `map`.

Разумеется, в качестве аргумента функции `map` мы можем использовать и наши собственные функции:

```haskell
ten :: [Double] -> [Double]
ten = map (\число -> число * 10)           -- сокращённая форма ten: функция map применяет лямбда-функцию ten с аргументом `число`
-- ten число = map (\число -> число * 10)  -- полная форма ten: функция map применяет лямбда-функцию ten с аргументом `число`

main :: IO ()
main = print . ten $ [1.2, 1, 4, 1.6]
```

Результат работы:

```bash
[12.0, 10.0, 40.0, 16.0]
```

Мы передали функции `map` нашу собственную Лямбда-функцию `ten`, умножающую свой единственный аргумент на `10`. Обратите внимание, мы вновь использовали краткую форму определения функции `ten`, опустив имя её аргумента - `число`. Раскроем подробнее:

```haskell
main = print .         ten        $ [1.2, 1,4, 1.6] =
                 _____/  \_____
                /              \
               /                \
main = print . map (\число -> число * 10) $ [1.2, 1,4, 1.6]
```

Вы спросите, как же вышло, что оператор применения расположен между двумя аргументами функции `map`? Разве он не предназначен для применения функции к единственному аргументу? Совершенно верно. Пришло время открыть ещё один секрет Haskell.

## Частичное применение функции

Функция `map` ожидает два аргумента, это отражено в её типе. Но что будет, если применить её не к двум аргументам, а лишь к одному? В этом случае произойдёт ещё одно &laquo;магическое&raquo; превращение, называющееся частичным применением функции. Частичным называют такое применение, когда аргументов меньше чем ожидается.

Вспомним сокращённое определение функции `ten`:

```haskell
ten = map (\n -> n * 10)

          1-й аргумент -   а где же
          функция которую  2-й аргумент
          надо применить   данные к которым
          к данным         эту функцию надо
          есть             применить ?
```

Функция `map` получила лишь 1-й аргумент, а где же 2-й аргумент? Второй, как мы уже знаем, будет получен ею уже потом, после того, как мы подставим это выражение на место функции `ten` в сторку 

main = print . ten $ [1.2, 1, 4, 1.6]

Но что же происходит с функцией `map` до этого? А до этого с ней происходит частичное применение. Понятно, что она ещё не может выполнить свою работу, поэтому, будучи применённой лишь к одному аргументу, она возвращает лямбда-функцию! Сопоставим с типом функции `map`, и всё встанет на свои места:

```haskell
map :: (a -> b)        -> [a]            -> [b]

map    (\n -> n * 10)

       только первый
       аргумент

│      частично     │
│    применённая    │
└─────── map ───────┘
                          аргумент          ответ
                          для частично
                          применённой
                          функции map

                          [1.2, 1,4, 1.6]
```

Тип лямбда-функции, возвращённой после применения `map` к первому аргументу &mdash; `[a] -> [b]`. Это &laquo;типовой хвост&raquo;, оставшийся от полного типа функции `map`:

```haskell
map :: (a -> b) -> [a]  ->  [b]

       голова      └── хвост ─┘
```

Поскольку голова в виде первого аргумента типа `(a -> b)` уже дана, осталось получить 2-й аргумент. Поэтому ЛФ, порождённая частичным применением, ожидает единственный аргумент, которым и будет тот самый второй, а именно список `[1.2, 1, 4, 1.6]`.

Сопоставим тип функции `ten` с типом `map`, чтобы понять, где наш хвост:

```haskell
ten ::             [Double] -> [Double]

map :: (a -> b) -> [a]      -> [b]

       голова      └────── хвост ─────┘
```

Вот почему мы можем использовать краткую форму определения для функции `ten`: она уже является нашим хвостом!

Рассмотрим ещё один пример частичного применения, дабы закрепить наше понимание:

```haskell
replace :: String -> String -> String -> String
```

Это объявление функции `replace`, принимающей 3 строки: 1-я содержит то, что ищем, 2-я содержит то, на что заменяем, а в 3-й лежит то, где ищем.

В 4-ю строку функция помещает результат.

Например:

```haskell
replace "http"
        "https"
        "http://ya.ru" = "https://ya.ru"
```

Определение (реализация) функции `replace` нас сейчас не интересует, рассмотрим пошаговое применение:

```haskell
main :: IO ()
main = putStrLn result
  where
    first  = replace "http"
    second = first   "https"
    result = second  "http://ya.ru"
```

Тип выражения `first` &mdash; `String -> String -> String`, оно явилось результатом частичного применения функции `replace` к 1-му аргументу, строке `"http"`. 

Тип выражения `second` &mdash; `String -> String`, оно явилось результатом вторичного частичного применения функции `first` к уже 2-му аргументу, строке `"https"`.

И наконец, применив функцию `second` к 3-му аргументу, строке `"http://ya.ru"`, мы наконец-то получаем конечный результат, ассоциированный с выражением `result`.

Из этого мы делаем интересное открытие:

> Функция от нескольких аргументов может быть разложена на последовательность применений временных функций от одного аргумента каждая.

Поэтому мы и смогли подставить частично применённую `map` на место выражения `ten`. Используем круглые скобки, чтобы яснее показать, что есть что:

```haskell
main = print . (map (\n -> n * 10)) $ [1.2, 1,4, 1.6]

               │     частично     │
               └─ применённая map ┘

       │    композиция функции    │
       │     print и частично     │
       └───── применённой map ────┘
                                      аргумент для
                                      композиции
```

Гибко, не правда ли? Теперь мы знакомы с частичным применением функции.

## Композиция для отображения

Вернёмся к функции `map`. Если мы можем передать ей некую функцию для работы с элементами списка, значит мы можем передать ей и композицию 2-х или более функций. Например:

```haskell
import Data.Char

pretty :: [String] -> [String]
pretty = map (stars . big)  -- передаёт функции "map" композицию из функций "stars . big"
  where
    big = map toUpper                 -- определение функции big - преобразует строку в верхний регистр
    stars = \s -> "* " ++ s ++ " *"   -- определение лямбда-функции stars - обрамляет строку звёздочками - ** строка **

main :: IO ()
main = print . pretty $ ["haskell", "lisp", "coq"]
```

Мы хотим украсить имена 3-х языков программирования. Для этого мы пробегаемся по списку композицией двух функций, `big` и `stars`. Функция `big` переводит строки в верхний регистр, а функция `stars` украшает имя двумя звёздочками в начале и в конце. В результате имеем:

```bash
["* HASKELL *","* LISP *","* COQ *"]
```

Пройтись по списку композицией `stars . big` равносильно тому, как если бы мы прошлись сначала функцией `big`, а затем функцией `stars`. При этом, как мы уже знаем, обе эти функции ничего не знают ни о том, что их скомпоновали, ни о том, что эту композицию передали функции `map`.

Ну что ж, теперь мы знаем о функции `map`, и последующих главах мы увидим множество других ФВП. Отныне они будут нашими постоянными спутниками.

